-- Content versions table for iterative editing and version tracking
CREATE TABLE IF NOT EXISTS public.content_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  draft_id UUID NOT NULL REFERENCES content_drafts(id) ON DELETE CASCADE,
  
  -- Version metadata
  version_number INTEGER NOT NULL DEFAULT 1,
  is_current BOOLEAN DEFAULT true,
  
  -- Sections (stored separately to enable section-level editing)
  hook TEXT,
  body TEXT,
  cta TEXT,
  visual_suggestions JSONB,
  
  -- Track which sections were modified in this version
  modified_sections TEXT[], -- ['hook', 'body', 'cta', 'visual_suggestions']
  
  -- Change metadata
  change_reason TEXT, -- e.g., "Make hook more funny", "Simplify language"
  changed_by_ai BOOLEAN DEFAULT false, -- true if regenerated by AI, false if manually edited
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Ensure version numbers are unique per draft
  UNIQUE(draft_id, version_number)
);

CREATE INDEX idx_content_versions_draft ON content_versions(draft_id);
CREATE INDEX idx_content_versions_current ON content_versions(draft_id, is_current) WHERE is_current = true;
CREATE INDEX idx_content_versions_created ON content_versions(created_at DESC);

-- RLS policies for content_versions
ALTER TABLE content_versions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage versions for their content drafts"
ON content_versions FOR ALL TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM content_drafts
    JOIN agents ON agents.id = content_drafts.agent_id
    JOIN spaces ON spaces.id = agents.space_id
    WHERE content_drafts.id = content_versions.draft_id
    AND spaces.user_id = auth.uid()
  )
);

-- Function to automatically increment version number
CREATE OR REPLACE FUNCTION increment_version_number()
RETURNS TRIGGER AS $$
BEGIN
  -- Set all previous versions to not current
  UPDATE content_versions 
  SET is_current = false 
  WHERE draft_id = NEW.draft_id AND id != NEW.id;
  
  -- Set version number if not provided
  -- Use advisory lock to prevent race conditions
  IF NEW.version_number IS NULL THEN
    PERFORM pg_advisory_xact_lock(hashtext('version_' || NEW.draft_id::text));
    NEW.version_number := COALESCE(
      (SELECT MAX(version_number) FROM content_versions WHERE draft_id = NEW.draft_id),
      0
    ) + 1;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_version_number
BEFORE INSERT ON content_versions
FOR EACH ROW
EXECUTE FUNCTION increment_version_number();

-- Add a column to content_drafts to track current version
ALTER TABLE content_drafts ADD COLUMN IF NOT EXISTS current_version_id UUID REFERENCES content_versions(id);

CREATE INDEX idx_content_drafts_current_version ON content_drafts(current_version_id);
